<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
><head
  ><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"
     /><meta name="viewport" content="width=device-width, initial-scale=1.0"
     /><title
    >Pipes.Prelude</title
    ><link href="purity.css" rel="stylesheet" type="text/css" title="Purity"
     /><link href="ocean.css" rel="alternate stylesheet" type="text/css" title="Ocean"
     /><script src="haddock-util.js" type="text/javascript"
    ></script
    ><script type="text/javascript"
    >//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Pipes-Prelude.html");};
//]]>
</script
    ></head
  ><body
  ><div id="package-header"
    ><ul class="links" id="page-menu"
      ><li
	><a href="index.html"
	  >Contents</a
	  ></li
	><li
	><a href="doc-index.html"
	  >Index</a
	  ></li
	></ul
      ><p class="caption"
      >pipes-4.1.7: Compositional pipelines</p
      ></div
    ><div id="content"
    ><h1 class="module-name"
      >Pipes.Prelude</h1
      ><div id="sidebar"
      ><div id="module-info"
	><table class="info"
	  ><tr
	    ><th
	      >Safe Haskell</th
	      ><td
	      >Trustworthy</td
	      ></tr
	    ></table
	  ></div
	><div id="table-of-contents"
	><p class="caption"
	  >Contents</p
	  ><ul
	  ><li
	    ><a href="#g:1"
	      >Producers</a
	      ></li
	    ><li
	    ><a href="#g:2"
	      >Consumers</a
	      ></li
	    ><li
	    ><a href="#g:3"
	      >Pipes</a
	      ></li
	    ><li
	    ><a href="#g:4"
	      >ListT</a
	      ></li
	    ><li
	    ><a href="#g:5"
	      >Folds</a
	      ></li
	    ><li
	    ><a href="#g:6"
	      >Zips</a
	      ></li
	    ><li
	    ><a href="#g:7"
	      >Utilities</a
	      ></li
	    ></ul
	  ></div
	></div
      ><div id="description"
      ><p class="caption"
	>Description</p
	><div class="doc"
	><p
	  >The names in this module clash heavily with the Haskell Prelude, so I
    recommend the following import scheme:</p
	  ><pre
	  >import Pipes
import qualified Pipes.Prelude as P  -- or use any other qualifier you prefer</pre
	  ><p
	  >Note that <code
	    >String</code
	    >-based <code
	    >IO</code
	    > is inefficient.  The <code
	    >String</code
	    >-based utilities
    in this module exist only for simple demonstrations without incurring a
    dependency on the <code
	    >text</code
	    > package.</p
	  ><p
	  >Also, <code
	    ><a href="Pipes-Prelude.html#v:stdinLn"
	      >stdinLn</a
	      ></code
	    > and <code
	    ><a href="Pipes-Prelude.html#v:stdoutLn"
	      >stdoutLn</a
	      ></code
	    > remove and add newlines, respectively.  This
    behavior is intended to simplify examples.  The corresponding <code
	    >stdin</code
	    > and
    <code
	    >stdout</code
	    > utilities from <code
	    >pipes-bytestring</code
	    > and <code
	    >pipes-text</code
	    > preserve
    newlines.</p
	  ></div
	></div
      ><div id="synopsis"
      ><p id="control.syn" class="caption expander" onclick="toggleSection('syn')"
	>Synopsis</p
	><ul id="section.syn" class="hide" onclick="toggleSection('syn')"
	><li class="src short"
	  ><a href="#v:stdinLn"
	    >stdinLn</a
	    > :: MonadIO m =&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > String m ()</li
	  ><li class="src short"
	  ><a href="#v:readLn"
	    >readLn</a
	    > :: (MonadIO m, Read a) =&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > a m ()</li
	  ><li class="src short"
	  ><a href="#v:fromHandle"
	    >fromHandle</a
	    > :: MonadIO m =&gt; Handle -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > String m ()</li
	  ><li class="src short"
	  ><a href="#v:repeatM"
	    >repeatM</a
	    > :: Monad m =&gt; m a -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > a m r</li
	  ><li class="src short"
	  ><a href="#v:replicateM"
	    >replicateM</a
	    > :: Monad m =&gt; Int -&gt; m a -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > a m ()</li
	  ><li class="src short"
	  ><a href="#v:unfoldr"
	    >unfoldr</a
	    > :: Monad m =&gt; (s -&gt; m (Either r (a, s))) -&gt; s -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r</li
	  ><li class="src short"
	  ><a href="#v:stdoutLn"
	    >stdoutLn</a
	    > :: MonadIO m =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > String m ()</li
	  ><li class="src short"
	  ><a href="#v:stdoutLn-39-"
	    >stdoutLn'</a
	    > :: MonadIO m =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > String m r</li
	  ><li class="src short"
	  ><a href="#v:mapM_"
	    >mapM_</a
	    > :: Monad m =&gt; (a -&gt; m ()) -&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > a m r</li
	  ><li class="src short"
	  ><a href="#v:print"
	    >print</a
	    > :: (MonadIO m, Show a) =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > a m r</li
	  ><li class="src short"
	  ><a href="#v:toHandle"
	    >toHandle</a
	    > :: MonadIO m =&gt; Handle -&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > String m r</li
	  ><li class="src short"
	  ><a href="#v:drain"
	    >drain</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > a m r</li
	  ><li class="src short"
	  ><a href="#v:map"
	    >map</a
	    > :: Monad m =&gt; (a -&gt; b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</li
	  ><li class="src short"
	  ><a href="#v:mapM"
	    >mapM</a
	    > :: Monad m =&gt; (a -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</li
	  ><li class="src short"
	  ><a href="#v:sequence"
	    >sequence</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > (m a) a m r</li
	  ><li class="src short"
	  ><a href="#v:mapFoldable"
	    >mapFoldable</a
	    > :: (Monad m, Foldable t) =&gt; (a -&gt; t b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</li
	  ><li class="src short"
	  ><a href="#v:filter"
	    >filter</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:filterM"
	    >filterM</a
	    > :: Monad m =&gt; (a -&gt; m Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:take"
	    >take</a
	    > :: Monad m =&gt; Int -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m ()</li
	  ><li class="src short"
	  ><a href="#v:takeWhile"
	    >takeWhile</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m ()</li
	  ><li class="src short"
	  ><a href="#v:takeWhile-39-"
	    >takeWhile'</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m a</li
	  ><li class="src short"
	  ><a href="#v:drop"
	    >drop</a
	    > :: Monad m =&gt; Int -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:dropWhile"
	    >dropWhile</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:concat"
	    >concat</a
	    > :: (Monad m, Foldable f) =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > (f a) a m r</li
	  ><li class="src short"
	  ><a href="#v:elemIndices"
	    >elemIndices</a
	    > :: (Monad m, Eq a) =&gt; a -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a Int m r</li
	  ><li class="src short"
	  ><a href="#v:findIndices"
	    >findIndices</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a Int m r</li
	  ><li class="src short"
	  ><a href="#v:scan"
	    >scan</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</li
	  ><li class="src short"
	  ><a href="#v:scanM"
	    >scanM</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</li
	  ><li class="src short"
	  ><a href="#v:chain"
	    >chain</a
	    > :: Monad m =&gt; (a -&gt; m ()) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:read"
	    >read</a
	    > :: (Monad m, Read a) =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > String a m r</li
	  ><li class="src short"
	  ><a href="#v:show"
	    >show</a
	    > :: (Monad m, Show a) =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a String m r</li
	  ><li class="src short"
	  ><a href="#v:seq"
	    >seq</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:loop"
	    >loop</a
	    > :: Monad m =&gt; (a -&gt; <a href="Pipes.html#t:ListT"
	    >ListT</a
	    > m b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</li
	  ><li class="src short"
	  ><a href="#v:fold"
	    >fold</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m b</li
	  ><li class="src short"
	  ><a href="#v:fold-39-"
	    >fold'</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; m (b, r)</li
	  ><li class="src short"
	  ><a href="#v:foldM"
	    >foldM</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m b</li
	  ><li class="src short"
	  ><a href="#v:foldM-39-"
	    >foldM'</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; m (b, r)</li
	  ><li class="src short"
	  ><a href="#v:all"
	    >all</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:any"
	    >any</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:and"
	    >and</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > Bool m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:or"
	    >or</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > Bool m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:elem"
	    >elem</a
	    > :: (Monad m, Eq a) =&gt; a -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:notElem"
	    >notElem</a
	    > :: (Monad m, Eq a) =&gt; a -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:find"
	    >find</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</li
	  ><li class="src short"
	  ><a href="#v:findIndex"
	    >findIndex</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe Int)</li
	  ><li class="src short"
	  ><a href="#v:head"
	    >head</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</li
	  ><li class="src short"
	  ><a href="#v:index"
	    >index</a
	    > :: Monad m =&gt; Int -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</li
	  ><li class="src short"
	  ><a href="#v:last"
	    >last</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</li
	  ><li class="src short"
	  ><a href="#v:length"
	    >length</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Int</li
	  ><li class="src short"
	  ><a href="#v:maximum"
	    >maximum</a
	    > :: (Monad m, Ord a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</li
	  ><li class="src short"
	  ><a href="#v:minimum"
	    >minimum</a
	    > :: (Monad m, Ord a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</li
	  ><li class="src short"
	  ><a href="#v:null"
	    >null</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</li
	  ><li class="src short"
	  ><a href="#v:sum"
	    >sum</a
	    > :: (Monad m, Num a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m a</li
	  ><li class="src short"
	  ><a href="#v:product"
	    >product</a
	    > :: (Monad m, Num a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m a</li
	  ><li class="src short"
	  ><a href="#v:toList"
	    >toList</a
	    > :: <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a Identity () -&gt; [a]</li
	  ><li class="src short"
	  ><a href="#v:toListM"
	    >toListM</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m [a]</li
	  ><li class="src short"
	  ><a href="#v:toListM-39-"
	    >toListM'</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; m ([a], r)</li
	  ><li class="src short"
	  ><a href="#v:zip"
	    >zip</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > b m r -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > (a, b) m r</li
	  ><li class="src short"
	  ><a href="#v:zipWith"
	    >zipWith</a
	    > :: Monad m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > b m r -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > c m r</li
	  ><li class="src short"
	  ><a href="#v:tee"
	    >tee</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Consumer"
	    >Consumer</a
	    > a m r -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</li
	  ><li class="src short"
	  ><a href="#v:generalize"
	    >generalize</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r -&gt; x -&gt; <a href="Pipes-Internal.html#t:Proxy"
	    >Proxy</a
	    > x a x b m r</li
	  ></ul
	></div
      ><div id="interface"
      ><h1 id="g:1"
	>Producers</h1
	><div class="doc"
	><p
	  >Use <code
	    ><a href="Pipes.html#v:for"
	      >for</a
	      ></code
	    > loops to iterate over <code
	    ><a href="Pipes-Core.html#t:Producer"
	      >Producer</a
	      ></code
	    >s whenever you want to perform the
    same action for every element:</p
	  ><pre
	  >-- Echo all lines from standard input to standard output
runEffect $ for P.stdinLn $ \str -&gt; do
    lift $ putStrLn str</pre
	  ><p
	  >... or more concisely:</p
	  ><pre class="screen"
	  ><code class="prompt"
	    >&gt;&gt;&gt; </code
	    ><strong class="userinput"
	    ><code
	      >runEffect $ for P.stdinLn (lift . putStrLn)
</code
	      ></strong
	    >Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
...
</pre
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:stdinLn" class="def"
	    >stdinLn</a
	    > :: MonadIO m =&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > String m ()</p
	  ><div class="doc"
	  ><p
	    >Read <code
	      >String</code
	      >s from <code
	      >stdin</code
	      > using <code
	      >IO.getLine</code
	      ></p
	    ><p
	    >Terminates on end of input</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:readLn" class="def"
	    >readLn</a
	    > :: (MonadIO m, Read a) =&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > a m ()</p
	  ><div class="doc"
	  ><p
	    ><code
	      ><a href="Pipes-Prelude.html#v:read"
		>read</a
		></code
	      > values from <code
	      >stdin</code
	      >, ignoring failed parses</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:fromHandle" class="def"
	    >fromHandle</a
	    > :: MonadIO m =&gt; Handle -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > String m ()</p
	  ><div class="doc"
	  ><p
	    >Read <code
	      >String</code
	      >s from a <code
	      >Handle</code
	      > using <code
	      >hGetLine</code
	      ></p
	    ><p
	    >Terminates on end of input</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:repeatM" class="def"
	    >repeatM</a
	    > :: Monad m =&gt; m a -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > a m r</p
	  ><div class="doc"
	  ><p
	    >Repeat a monadic action indefinitely, <code
	      ><a href="Pipes.html#v:yield"
		>yield</a
		></code
	      >ing each result</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:replicateM" class="def"
	    >replicateM</a
	    > :: Monad m =&gt; Int -&gt; m a -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > a m ()</p
	  ><div class="doc"
	  ><p
	    >Repeat a monadic action a fixed number of times, <code
	      ><a href="Pipes.html#v:yield"
		>yield</a
		></code
	      >ing each result</p
	    ><pre
	    >replicateM  0      x = return ()

replicateM (m + n) x = replicateM m x &gt;&gt; replicateM n x  -- 0 &lt;= {m,n}</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:unfoldr" class="def"
	    >unfoldr</a
	    > :: Monad m =&gt; (s -&gt; m (Either r (a, s))) -&gt; s -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r</p
	  ><div class="doc"
	  ><p
	    >The natural unfold into a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > with a step function and a seed </p
	    ><pre
	    >unfoldr next = id</pre
	    ></div
	  ></div
	><h1 id="g:2"
	>Consumers</h1
	><div class="doc"
	><p
	  >Feed a <code
	    ><a href="Pipes-Core.html#t:Consumer"
	      >Consumer</a
	      ></code
	    > the same value repeatedly using (<code
	    ><a href="Pipes.html#v:-62--126-"
	      >&gt;~</a
	      ></code
	    >):</p
	  ><pre class="screen"
	  ><code class="prompt"
	    >&gt;&gt;&gt; </code
	    ><strong class="userinput"
	    ><code
	      >runEffect $ lift getLine &gt;~ P.stdoutLn
</code
	      ></strong
	    >Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
...
</pre
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:stdoutLn" class="def"
	    >stdoutLn</a
	    > :: MonadIO m =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > String m ()</p
	  ><div class="doc"
	  ><p
	    >Write <code
	      >String</code
	      >s to <code
	      >stdout</code
	      > using <code
	      >IO.putStrLn</code
	      ></p
	    ><p
	    >Unlike <code
	      ><a href="Pipes-Prelude.html#v:toHandle"
		>toHandle</a
		></code
	      >, <code
	      ><a href="Pipes-Prelude.html#v:stdoutLn"
		>stdoutLn</a
		></code
	      > gracefully terminates on a broken output pipe</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:stdoutLn-39-" class="def"
	    >stdoutLn'</a
	    > :: MonadIO m =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > String m r</p
	  ><div class="doc"
	  ><p
	    >Write <code
	      >String</code
	      >s to <code
	      >stdout</code
	      > using <code
	      >IO.putStrLn</code
	      ></p
	    ><p
	    >This does not handle a broken output pipe, but has a polymorphic return
    value</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:mapM_" class="def"
	    >mapM_</a
	    > :: Monad m =&gt; (a -&gt; m ()) -&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > a m r</p
	  ><div class="doc"
	  ><p
	    >Consume all values using a monadic function</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:print" class="def"
	    >print</a
	    > :: (MonadIO m, Show a) =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > a m r</p
	  ><div class="doc"
	  ><p
	    ><code
	      ><a href="Pipes-Prelude.html#v:print"
		>print</a
		></code
	      > values to <code
	      >stdout</code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:toHandle" class="def"
	    >toHandle</a
	    > :: MonadIO m =&gt; Handle -&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > String m r</p
	  ><div class="doc"
	  ><p
	    >Write <code
	      >String</code
	      >s to a <code
	      >Handle</code
	      > using <code
	      >hPutStrLn</code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:drain" class="def"
	    >drain</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Consumer-39-"
	    >Consumer'</a
	    > a m r</p
	  ><div class="doc"
	  ><p
	    ><code
	      ><a href="Pipes.html#v:discard"
		>discard</a
		></code
	      > all incoming values</p
	    ></div
	  ></div
	><h1 id="g:3"
	>Pipes</h1
	><div class="doc"
	><p
	  >Use (<code
	    ><a href="Pipes.html#v:-62--45--62-"
	      >&gt;-&gt;</a
	      ></code
	    >) to connect <code
	    ><a href="Pipes-Core.html#t:Producer"
	      >Producer</a
	      ></code
	    >s, <code
	    ><a href="Pipes-Core.html#t:Pipe"
	      >Pipe</a
	      ></code
	    >s, and <code
	    ><a href="Pipes-Core.html#t:Consumer"
	      >Consumer</a
	      ></code
	    >s:</p
	  ><pre class="screen"
	  ><code class="prompt"
	    >&gt;&gt;&gt; </code
	    ><strong class="userinput"
	    ><code
	      >runEffect $ P.stdinLn &gt;-&gt; P.takeWhile (/= &quot;quit&quot;) &gt;-&gt; P.stdoutLn
</code
	      ></strong
	    >Test&lt;Enter&gt;
Test
ABC&lt;Enter&gt;
ABC
quit&lt;Enter&gt;
<code class="prompt"
	    >&gt;&gt;&gt; </code
	    ><strong class="userinput"
	    ><code
	      >
</code
	      ></strong
	    ></pre
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:map" class="def"
	    >map</a
	    > :: Monad m =&gt; (a -&gt; b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</p
	  ><div class="doc"
	  ><p
	    >Apply a function to all values flowing downstream</p
	    ><pre
	    >map id = cat

map (g . f) = map f &gt;-&gt; map g</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:mapM" class="def"
	    >mapM</a
	    > :: Monad m =&gt; (a -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</p
	  ><div class="doc"
	  ><p
	    >Apply a monadic function to all values flowing downstream</p
	    ><pre
	    >mapM return = cat

mapM (f &gt;=&gt; g) = mapM f &gt;-&gt; mapM g</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:sequence" class="def"
	    >sequence</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > (m a) a m r</p
	  ><div class="doc"
	  ><p
	    >Convert a stream of actions to a stream of values</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:mapFoldable" class="def"
	    >mapFoldable</a
	    > :: (Monad m, Foldable t) =&gt; (a -&gt; t b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</p
	  ><div class="doc"
	  ><p
	    >Apply a function to all values flowing downstream, and
     forward each element of the result.</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:filter" class="def"
	    >filter</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(filter predicate)</code
	      > only forwards values that satisfy the predicate.</p
	    ><pre
	    >filter (pure True) = cat

filter (liftA2 (&amp;&amp;) p1 p2) = filter p1 &gt;-&gt; filter p2</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:filterM" class="def"
	    >filterM</a
	    > :: Monad m =&gt; (a -&gt; m Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(filterM predicate)</code
	      > only forwards values that satisfy the monadic
    predicate</p
	    ><pre
	    >filterM (pure (pure True)) = cat

filterM (liftA2 (liftA2 (&amp;&amp;)) p1 p2) = filterM p1 &gt;-&gt; filterM p2</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:take" class="def"
	    >take</a
	    > :: Monad m =&gt; Int -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m ()</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(take n)</code
	      > only allows <code
	      >n</code
	      > values to pass through</p
	    ><pre
	    >take 0 = return ()

take (m + n) = take m &gt;&gt; take n</pre
	    ><pre
	    >take &lt;infinity&gt; = cat

take (min m n) = take m &gt;-&gt; take n</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:takeWhile" class="def"
	    >takeWhile</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m ()</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(takeWhile p)</code
	      > allows values to pass downstream so long as they satisfy
    the predicate <code
	      >p</code
	      >.</p
	    ><pre
	    >takeWhile (pure True) = cat

takeWhile (liftA2 (&amp;&amp;) p1 p2) = takeWhile p1 &gt;-&gt; takeWhile p2</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:takeWhile-39-" class="def"
	    >takeWhile'</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m a</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(takeWhile' p)</code
	      > is a version of takeWhile that returns the value failing
    the predicate.</p
	    ><pre
	    >takeWhile' (pure True) = cat

takeWhile' (liftA2 (&amp;&amp;) p1 p2) = takeWhile' p1 &gt;-&gt; takeWhile' p2</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:drop" class="def"
	    >drop</a
	    > :: Monad m =&gt; Int -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(drop n)</code
	      > discards <code
	      >n</code
	      > values going downstream</p
	    ><pre
	    >drop 0 = cat

drop (m + n) = drop m &gt;-&gt; drop n</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:dropWhile" class="def"
	    >dropWhile</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(dropWhile p)</code
	      > discards values going downstream until one violates the
    predicate <code
	      >p</code
	      >.</p
	    ><pre
	    >dropWhile (pure False) = cat

dropWhile (liftA2 (||) p1 p2) = dropWhile p1 &gt;-&gt; dropWhile p2</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:concat" class="def"
	    >concat</a
	    > :: (Monad m, Foldable f) =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > (f a) a m r</p
	  ><div class="doc"
	  ><p
	    >Flatten all <code
	      >Foldable</code
	      > elements flowing downstream</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:elemIndices" class="def"
	    >elemIndices</a
	    > :: (Monad m, Eq a) =&gt; a -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a Int m r</p
	  ><div class="doc"
	  ><p
	    >Outputs the indices of all elements that match the given element</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:findIndices" class="def"
	    >findIndices</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a Int m r</p
	  ><div class="doc"
	  ><p
	    >Outputs the indices of all elements that satisfied the predicate</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:scan" class="def"
	    >scan</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</p
	  ><div class="doc"
	  ><p
	    >Strict left scan</p
	    ><pre
	    >Control.Foldl.purely scan :: Monad m =&gt; Fold a b -&gt; Pipe a b m r</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:scanM" class="def"
	    >scanM</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</p
	  ><div class="doc"
	  ><p
	    >Strict, monadic left scan</p
	    ><pre
	    >Control.Foldl.impurely scan :: Monad m =&gt; FoldM a m b -&gt; Pipe a b m r</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:chain" class="def"
	    >chain</a
	    > :: Monad m =&gt; (a -&gt; m ()) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    >Apply an action to all values flowing downstream</p
	    ><pre
	    >chain (pure (return ())) = cat

chain (liftA2 (&gt;&gt;) m1 m2) = chain m1 &gt;-&gt; chain m2</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:read" class="def"
	    >read</a
	    > :: (Monad m, Read a) =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > String a m r</p
	  ><div class="doc"
	  ><p
	    >Parse <code
	      >Read</code
	      >able values, only forwarding the value if the parse succeeds</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:show" class="def"
	    >show</a
	    > :: (Monad m, Show a) =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a String m r</p
	  ><div class="doc"
	  ><p
	    >Convert <code
	      >Show</code
	      >able values to <code
	      >String</code
	      >s</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:seq" class="def"
	    >seq</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    >Evaluate all values flowing downstream to WHNF</p
	    ></div
	  ></div
	><h1 id="g:4"
	>ListT</h1
	><div class="top"
	><p class="src"
	  ><a name="v:loop" class="def"
	    >loop</a
	    > :: Monad m =&gt; (a -&gt; <a href="Pipes.html#t:ListT"
	    >ListT</a
	    > m b) -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r</p
	  ><div class="doc"
	  ><p
	    >Create a <code
	      ><a href="Pipes-Core.html#t:Pipe"
		>Pipe</a
		></code
	      > from a <code
	      ><a href="Pipes.html#t:ListT"
		>ListT</a
		></code
	      > transformation</p
	    ><pre
	    >loop (k1 &gt;=&gt; k2) = loop k1 &gt;-&gt; loop k2

loop return = cat</pre
	    ></div
	  ></div
	><h1 id="g:5"
	>Folds</h1
	><div class="doc"
	><p
	  >Use these to fold the output of a <code
	    ><a href="Pipes-Core.html#t:Producer"
	      >Producer</a
	      ></code
	    >.  Many of these folds will stop
    drawing elements if they can compute their result early, like <code
	    ><a href="Pipes-Prelude.html#v:any"
	      >any</a
	      ></code
	    >:</p
	  ><pre class="screen"
	  ><code class="prompt"
	    >&gt;&gt;&gt; </code
	    ><strong class="userinput"
	    ><code
	      >P.any null P.stdinLn
</code
	      ></strong
	    >Test&lt;Enter&gt;
ABC&lt;Enter&gt;
&lt;Enter&gt;
True
<code class="prompt"
	    >&gt;&gt;&gt; </code
	    ><strong class="userinput"
	    ><code
	      >
</code
	      ></strong
	    ></pre
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:fold" class="def"
	    >fold</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m b</p
	  ><div class="doc"
	  ><p
	    >Strict fold of the elements of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ><pre
	    >Control.Foldl.purely fold :: Monad m =&gt; Fold a b -&gt; Producer a m () -&gt; m b</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:fold-39-" class="def"
	    >fold'</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; x) -&gt; x -&gt; (x -&gt; b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; m (b, r)</p
	  ><div class="doc"
	  ><p
	    >Strict fold of the elements of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > that preserves the return value</p
	    ><pre
	    >Control.Foldl.purely fold' :: Monad m =&gt; Fold a b -&gt; Producer a m r -&gt; m (b, r)</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:foldM" class="def"
	    >foldM</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m b</p
	  ><div class="doc"
	  ><p
	    >Strict, monadic fold of the elements of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ><pre
	    >Control.Foldl.impurely foldM :: Monad m =&gt; FoldM a b -&gt; Producer a m () -&gt; m b</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:foldM-39-" class="def"
	    >foldM'</a
	    > :: Monad m =&gt; (x -&gt; a -&gt; m x) -&gt; m x -&gt; (x -&gt; m b) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; m (b, r)</p
	  ><div class="doc"
	  ><p
	    >Strict, monadic fold of the elements of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ><pre
	    >Control.Foldl.impurely foldM' :: Monad m =&gt; FoldM a b -&gt; Producer a m r -&gt; m (b, r)</pre
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:all" class="def"
	    >all</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(all predicate p)</code
	      > determines whether all the elements of <code
	      >p</code
	      > satisfy the
    predicate.</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:any" class="def"
	    >any</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(any predicate p)</code
	      > determines whether any element of <code
	      >p</code
	      > satisfies the
    predicate.</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:and" class="def"
	    >and</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > Bool m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    >Determines whether all elements are <code
	      >True</code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:or" class="def"
	    >or</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > Bool m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    >Determines whether any element is <code
	      >True</code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:elem" class="def"
	    >elem</a
	    > :: (Monad m, Eq a) =&gt; a -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(elem a p)</code
	      > returns <code
	      >True</code
	      > if <code
	      >p</code
	      > has an element equal to <code
	      >a</code
	      >, <code
	      >False</code
	      >
    otherwise</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:notElem" class="def"
	    >notElem</a
	    > :: (Monad m, Eq a) =&gt; a -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    ><code
	      >(notElem a)</code
	      > returns <code
	      >False</code
	      > if <code
	      >p</code
	      > has an element equal to <code
	      >a</code
	      >, <code
	      >True</code
	      >
    otherwise</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:find" class="def"
	    >find</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</p
	  ><div class="doc"
	  ><p
	    >Find the first element of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > that satisfies the predicate</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:findIndex" class="def"
	    >findIndex</a
	    > :: Monad m =&gt; (a -&gt; Bool) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe Int)</p
	  ><div class="doc"
	  ><p
	    >Find the index of the first element of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > that satisfies the
    predicate</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:head" class="def"
	    >head</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</p
	  ><div class="doc"
	  ><p
	    >Retrieve the first element from a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:index" class="def"
	    >index</a
	    > :: Monad m =&gt; Int -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</p
	  ><div class="doc"
	  ><p
	    >Index into a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:last" class="def"
	    >last</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</p
	  ><div class="doc"
	  ><p
	    >Retrieve the last element from a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:length" class="def"
	    >length</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Int</p
	  ><div class="doc"
	  ><p
	    >Count the number of elements in a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:maximum" class="def"
	    >maximum</a
	    > :: (Monad m, Ord a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</p
	  ><div class="doc"
	  ><p
	    >Find the maximum element of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:minimum" class="def"
	    >minimum</a
	    > :: (Monad m, Ord a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m (Maybe a)</p
	  ><div class="doc"
	  ><p
	    >Find the minimum element of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:null" class="def"
	    >null</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m Bool</p
	  ><div class="doc"
	  ><p
	    >Determine if a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > is empty</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:sum" class="def"
	    >sum</a
	    > :: (Monad m, Num a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m a</p
	  ><div class="doc"
	  ><p
	    >Compute the sum of the elements of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:product" class="def"
	    >product</a
	    > :: (Monad m, Num a) =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m a</p
	  ><div class="doc"
	  ><p
	    >Compute the product of the elements of a <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      ></p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:toList" class="def"
	    >toList</a
	    > :: <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a Identity () -&gt; [a]</p
	  ><div class="doc"
	  ><p
	    >Convert a pure <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > into a list</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:toListM" class="def"
	    >toListM</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m () -&gt; m [a]</p
	  ><div class="doc"
	  ><p
	    >Convert an effectful <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > into a list</p
	    ><p
	    >Note: <code
	      ><a href="Pipes-Prelude.html#v:toListM"
		>toListM</a
		></code
	      > is not an idiomatic use of <code
	      >pipes</code
	      >, but I provide it for
    simple testing purposes.  Idiomatic <code
	      >pipes</code
	      > style consumes the elements
    immediately as they are generated instead of loading all elements into
    memory.</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:toListM-39-" class="def"
	    >toListM'</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; m ([a], r)</p
	  ><div class="doc"
	  ><p
	    >Convert an effectful <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      > into a list alongside the return value</p
	    ><p
	    >Note: <code
	      ><a href="Pipes-Prelude.html#v:toListM-39-"
		>toListM'</a
		></code
	      > is not an idiomatic use of <code
	      >pipes</code
	      >, but I provide it for
    simple testing purposes.  Idiomatic <code
	      >pipes</code
	      > style consumes the elements
    immediately as they are generated instead of loading all elements into
    memory.</p
	    ></div
	  ></div
	><h1 id="g:6"
	>Zips</h1
	><div class="top"
	><p class="src"
	  ><a name="v:zip" class="def"
	    >zip</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > b m r -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > (a, b) m r</p
	  ><div class="doc"
	  ><p
	    >Zip two <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      >s</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:zipWith" class="def"
	    >zipWith</a
	    > :: Monad m =&gt; (a -&gt; b -&gt; c) -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > a m r -&gt; <a href="Pipes-Core.html#t:Producer"
	    >Producer</a
	    > b m r -&gt; <a href="Pipes-Core.html#t:Producer-39-"
	    >Producer'</a
	    > c m r</p
	  ><div class="doc"
	  ><p
	    >Zip two <code
	      ><a href="Pipes-Core.html#t:Producer"
		>Producer</a
		></code
	      >s using the provided combining function</p
	    ></div
	  ></div
	><h1 id="g:7"
	>Utilities</h1
	><div class="top"
	><p class="src"
	  ><a name="v:tee" class="def"
	    >tee</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Consumer"
	    >Consumer</a
	    > a m r -&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a a m r</p
	  ><div class="doc"
	  ><p
	    >Transform a <code
	      ><a href="Pipes-Core.html#t:Consumer"
		>Consumer</a
		></code
	      > to a <code
	      ><a href="Pipes-Core.html#t:Pipe"
		>Pipe</a
		></code
	      > that reforwards all values further
    downstream</p
	    ></div
	  ></div
	><div class="top"
	><p class="src"
	  ><a name="v:generalize" class="def"
	    >generalize</a
	    > :: Monad m =&gt; <a href="Pipes-Core.html#t:Pipe"
	    >Pipe</a
	    > a b m r -&gt; x -&gt; <a href="Pipes-Internal.html#t:Proxy"
	    >Proxy</a
	    > x a x b m r</p
	  ><div class="doc"
	  ><p
	    >Transform a unidirectional <code
	      ><a href="Pipes-Core.html#t:Pipe"
		>Pipe</a
		></code
	      > to a bidirectional <code
	      ><a href="Pipes-Internal.html#t:Proxy"
		>Proxy</a
		></code
	      ></p
	    ><pre
	    >generalize (f &gt;-&gt; g) = generalize f &gt;+&gt; generalize g

generalize cat = pull</pre
	    ></div
	  ></div
	></div
      ></div
    ><div id="footer"
    ><p
      >Produced by <a href="http://www.haskell.org/haddock/"
	>Haddock</a
	> version 2.16.1</p
      ></div
    ></body
  ></html
>
